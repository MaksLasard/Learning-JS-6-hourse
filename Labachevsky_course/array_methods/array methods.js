const arr = ['a', 'b', 2, 'd', 'i', 'dd']
const arrTwo = [10, 2, 312, 12, 16, 31, 62, 7]

console.log('START:', arr)
// Хорошие фунции это чистые функции. 

// spread - разбирает массив на элементы
// Как правило это нужно чтобы передать значения массива в какую-то функцию. Если в массиве много элементов и нужно передать каждый элемент по отдельности


// rest - пишется внутри определения функции передает все аргументы в функцию в виде массива
// rest - Служит для сбора параметров
// const arrFunc = (...arr) => {
//     console.log(arr)
// }
// arrFunc(1, 2, 3, 4, 5, 7)


// Метод slice(start, end) - создает новый массив, копируя в него элементы с позиции start до end (не включая end) 
// const res1 = arr.slice(0, 2)
// console.log(res1)
// const res2 = arr.slice(-2)
// console.log(res2)
// const res3 = [...res1, ...res2]
// console.log(res3)
// При этом сам массив не меняется
// Может принимать отрицательное число и тем самым отсчитвать позицию с конца
// slice не меняет массив, он создает новый массив с частью исходного массива


// Метод concat(...items) - возвращает новый массив: копирует все элементы текущего массива и добавляет к нему items
// Если items является массивом, тогда берутся его элементы
// Если передадим массив, этот массив раскроется на аргументы. Если вложенность массива будет больше чем 1, то вложенный массив останется массивом
// Сейчас concat() заменяется spread оператором
// const arr1 = arr.concat(...arrTwo, [1,2,3,4,5,6,7])
// console.log(arr1)

// includes(value) - возвращает true, если в массиве имеется элемент value, в противном случае false
// Ищет элемент внутри массива, и возвращает элемет если от есть
// const res = arr.includes('c')
// console.log(res)
// Значит что 'c' включено в массив arr. Поиск в массиве с ответом 'Да' или 'Нет'
// При поиске объекта, поиск совершается по значению, а когда мы ищим объект мы ищем объекты с разными ссылками, и соответсвенно false
// Работает только с примитивами, с ссылочными типами он не работает 
// Чтобы он сработал нам нужно заранее создать объект и передать его для поиска
// const obj = {}
// const arr = ['a', 'b', 'c', 'd', 'i', obj]
// const res = arr.includes(obj)


// indexOf / lastIndexOf(items, pos) - ишет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено
// indexOf - По сути тоже самое только возвращается индекс элемента. Возвращается только первый найденый элемент
// lastIndexOf - Тоже самое, только поиск идет с конца. Если ничего не найдено, вернется -1


// find/filter(func) - фильтрует элементы через функцию и отдает первое/все значения, при прохождении которых через функцию возвращается true
// const res = arr.find((item, index, array) => {
//     console.log(index, item)
//     return item === 'c'
// })
// console.log(res)
// Часто пишут в сокращенной записи
// const res = arr.find(item => item.length === 4)

// const res = arr.filter(item => {
//     return item.length === 1
// })
// console.log(res)

// const res = arr.filter(item => typeof(item) === 'string')
// console.log(res)
// filter - возвращает массив


// findIndex(func) - похож на find, но возвращает индекс вместо значения
// const res = arr.findIndex(item => item.length === 2)
// console.log(res)

// const res = arrTwo.map(item => item + 1)
// console.log(res)

// Метод sort() - сортирует массив
// Метод sort() - модифицирует изначальный массив. Что отсортировать массив не изменив изначальный, мы можем его скопировать
// Нам нужно создать массив с элементами старого: const res = [...arrTwo].sort()
// const res = [...arrTwo].sort()
// console.log(res)
// Это называется лексико-графическая сортировка. Это отсортировать все элементы массива предварительно преобразовав их к строке.
// А далее они отсортируются в алфовитном порядке

// const res = [...arrTwo].sort((a, b) => a - b) - сортировка чисел по возрастанию
// const res = [...arrTwo].sort((a, b) => b - a) - сортировка чисел по убыванию

// const res = [...arrTwo].sort((a, b) => {
//     if( typeof(a) === 'string' && typeof(b) === 'string') {
//         return a.localeCompare(b)
//     }
//     return -1
// })


// Метод reverse() - меняет порядок следования элементов на противоположный и возвращает измененный массив
// Также как и sort() модифицирует исходный массив


// Метод splite/join - преобразуют строку в массив и обратно. 
// const res = arr.join(' > ') // По умолчанию через запятую
// console.log(res)
// Как аргумент передаем разделитель. Учитвается даже пробел

// const res = 'Строка, строка, строка'.split(',') // По умолчанию через запятую
// console.log(res)
// Сам разделитель не попадает в выборку


// Метод reduce() - вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами
// При сложении массива чисел будет 1 число сумма элементов массива
// При сложении массива строк будет конкатенация













console.log('FINAL:', arr)