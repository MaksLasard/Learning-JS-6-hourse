/*
Стек вызовов: 
    - 

У нас есть стек вызовов, это то что у нас работает по модели last in first out
Т.е когда мы что-то туда закинули, то что будет последним он будет разбираться в обратном порядке 

Также у нас есть очереди callback. Т.к event loop имеет разные фазы, то соответственно для каждой фазы у нас есть своя очередь
У нас есть очередь callback для таймеров/input autput и тд

setTimeout - не может оставаться в callstack т.к он будет блокировать дальшейнее выполнение 

Когда проходит 1 сек наш timeout возвращается в очередь callback
И когда event loop дойдет до нашей первой фазы заново, timeout передет в стек и мы ее выполним

Нужно понимать, что если у нас стек забит мы ничего не можем делать

Как только мы вызываем какую-то ассинхронную обработку/ассинхронные вещи которые должны выполняться долго, они уходят в обработку и 
затем возвращаются как будут готовы 


Worker Threads:
    - Дополнительные потоки. Запускаются когда нам нужно сделать 

Callstack когда видит тяжелую задачу, он ее делегирует Worker Thread и в результате возвращает callback

На самом деле не все длительные задачи выполняются в worker threads


У нас есть основной процесс где наш JS вызывает какую-то функцию которая требует длительной обработки и не синхронного вызова
Эта функция между JS передается в C++ через binding. С++ распаковывает JS объект, понимает что это за задача и отправляет эту задачу
Как только у нас есть задача обрабатывается запрос и она отдается в worker thread.

В свою очередь как только C++ отдал задачу, говорит "Ок. Все. Я это сделал" и происходит возврат к JS коду и продолжение работы
В worker thread выполняется задача. После выполнения происходит передача в C++ и запаковка объекта. После чего вызывается callback

Несмотря на то что в Main Thread происходит постоянный обмен между JS и C++ и все тяжеловесные задачи будут делегированы worker thread
На самом деле worker thread всего 4. Почему 4? Так устроен Libuv, и на самом деле большинство задач которые мы будем делать они никак не связаны с worker thread


Есть 2 различных способа вызова наших ассинхронных объектов: По умолчанию потоков 4. Но можно увеличить до 1024   
    - Worker Thread (Работают только для части операций)
        - Все файловые операции fs.*
        - dns.lookup
        - Pipes(Некоторые случаи)
        - CPU intense tasks (шифрование)

    - Системные ассинхронные вызовы на уровне ядра
        - TCP / UDP сервер и клиент
        - Pipes
        - DNS resolve
        - Child process

Почему 4? 4 означает что у нас есть 4 ядерный процессор который паралельно спокойно может выполнить 4 потока не теряя производительность
Если у нас 8 поток, но 4 ядерный процессор, он их выполнить, но будет выполнять друг за другом т.к наши ядра заняты
Число потоков можно задавать по кол-ву ядер чтобы выполнять CPU задачи

Пример из практики:

Действия в цикле выполняются по 4 пачки. Т.к мы выполняем Thread Pool и паралельно можем выполнять только 4 операции
Как только потоки освобождаются переходят к следующему
Плюс операции не всегда равны, одно + время другого т.к есть еще какое-то время на переключение операций


Расширение Thread Pool до 8: - process.env.UV_THREADPOOL_SIZE = 8

Выполнения на Thread Pool за счет ядер процессора

for (let i = 0; i < 50; i++) {
    crypto.pbkdf2('test', 'salt', 100000, 64, 'sha512', () => {
        console.log(performance.now() - start)
    })
}

Выполнения на запросах ядра делает шаг задач минимальным т.к у нас нет ограничения

for (let i = 0; i < 50; i++) {
    https.get('https://yandex.ru', (res) => {
        res.on('data', () => { }),
        res.on('end', () => {
            console.log(performance.now() - start)
        })
    })
}

Измерение производительности:
    - 


































*/