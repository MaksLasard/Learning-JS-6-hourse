/*
Type Annotations (Аннотации типов) и Type Inference (Вывод типов): 

Type Annotations (Аннотации типов) - код который мы добавляем в TypeScript, чтобы он понял,
значение какого типа будут содержаться в переменной 

Type Inference (Вывод типов) - TypeScript пытается сам определить, значения какого типа 
будут содержаться в переменной

Type Annotations (Аннотации типов): Мы как разработчики указываем тип для TypeScript
Type Inference (Вывод типов): TypeScript сам угадывает тип


Анотации для переменных: 

const oranges: number = 5;
const speed: string = 'fast'
cosnt hasDog: boolean = true

const nothing: null = null
const nothingOne: undefined = undefined

:number - это как раз анатация типов. Анотация типа number
Эта аннотация говорит что переменной oranges мы будем присваивать значения только типа число (number)
Если мы попытаемся присвоить любой другой тип данных, то получим ошибку в IDE
Тоже самое произошло даже при использовании ключевого слова let

Для встроенных объектов:
const now: Date = new Date()


Аннотации типов для объектных литералов: 
const array: string[] | number[]  = ['1', '2', '3']

Сама аннотация не создает массив. Она просто говорит что мы будем присваивать переменной array
что-то что является массивом из строк

Аннотации типов для классов:
class Car {

} 
let car: Car = new Car()

В данном случае мы говорим, что в переменной car будут содержатся объекты типа класса Car

Объектные литералы: 
const point: {x: number; y: number} = {
    x: 10,
    y: 20
}

Мы должны поместить двоеточие после названия переменной
А дальше хотим указать какой тип мы хотим присваивать этой переменной указываем фигурные скобки {}
Чтобы указывать свойства этого объекта и их типы

У этого объекта есть свойство x: number - с типом число. Далее нужно разделять из точкой с запятой
Мы должны разделять анотацию типов свойств объектоно литерала точкой с запятой ;
Тем самым мы говорим что мы можем содержать свойства только числового типа

Если мы хотим изменить ключ например на a, то будет ошибка т.к в аннотации указана переменная x


Аннотации для функций: 
const logNumber: (i: number) => void = (i: number) => {
    console.log(i)
}

После двоеточия logNmber: идет аннотация 

Для функции, для нас как разработчиков важны 2 вещи: 1. Параметры которые принимает функция. 2. Возвращаемое значение
Здесь мы должны написать какие различные параметры будет принимать функция
И какие различне значения она будет возвращать

Прежде всего нужно указать в круглых скобках какие параметры будет принимать данная функция
После этого нам нужно указать, какие значения будет возвращать эта функция мы должны указать после стрелки
В данном случае наша функция не возвращает ничего void (тип значит пустой)


Что такое вывод типов?
- Когда мы наводим курсор на переменную TypeScript все равно понимает какой тип значения мы будем присваевать этой переменной
Даже без анатаций типов. Это система вывода в действии

Если объявление и инициализация переменной происходят в одной строке TS может понять тип значения 'color'

      1         2
const color = 'red'

1. Объявление переменной (декларация)
2. Инициализация

Т.е все анатации типом можно не использовать т.к TS догадывается какой тип у переменной должен быть
Если мы делаем декларацию и инициализацию в одной строке TS догадывается какие значения мы будем хранить в этой переменной
И делает так называемый вывод типов. TS делает вывод что в переменной oranges будут хранится значения только числового типа

Когда нам добавлять типовые анотации?

Type Annotations (Аннотации типов)
- Когда переменная объявляется, а инициализируется позже
- Когда создается переменная, вывод о типе которой не может быть сделан
- Когда функция возвращает тип 'any' и нам нужно уточнить тип

Type Inference (Вывод типов)
- Всегда 

Тип 'Any'

Когда использовать аннотации типов: 
    - Когда функция возвращает тип 'any' и нам нужно уточнить тип

const json = '{"x": 10, "y": 20}'
const coordinates: {x: number; y: number} = JSON.parse(json)

Метод JSON.parse() возвращает тип 'any'

Как работает метод JSON.parse()?
    - При передачи значения в метод у них остается тип который их принадлежит
Но TypeScript определяет их как тип 'any'

Каждый раз как мы передаем строку в метод parse(), то мы получаем разные значения
И проблема в том что TypeScript не может предсказать все эти разные значения. 
Не можем предсказать, что же мы все таки получим из этого метода

Потому-что это зависит полностью от того какую строку мы передаем в этот метод

Тип 'any':
    - Такой же тип, как например 'string' или 'number'
    - Это значит, что TS понятия не имеет что это и не может проверить на содержание ошибок 
    - Избегайте переменных с типом 'any' любой ценой

TypeScript - зная все типы может проверять, правельно ли мы используем вызов свойств или функций для этой переменной
Потому-что он знает какие значения какого типа содержатся в переменной и может нам указать на ошибку или опечатку
И когда мы получаем тип any TypeScript не может ничего исправить и подсказать


Исправление типа 'any':
    - Один из способов это добавить анотацию типов переменной
Так мы в переменной парсим из JSON в объект, то аннотацию типов нужно использовать как для объекта

const coordinates: {x: number; y: number} = JSON.parse(json)

Все что нужно сделать, это каждый раз когда возвращается тип any добавлять аннотацию типов


Отложенная инициализация: 
    - Когда переменная объявляется, а инициализируется позже

let words = ['one', 'two', 'tree']
let isTwo: boolean;

for (let i = 0; i < words.lenght; i++) {
    if (words[i] === 'two') {
        isTwo = true
    }
}

Каждый раз когда мы делаем объявление и присваивание значение в разных местах кода нам нужно вручную добавлять аннотацию типов

Когда создается переменная, вывод о типе которой не может быть сделан:
    
let myNumbers = [-10, -1, 12]
let positiveNumber: boolean | number = false
for (let i = 0; i < myNumbers.length; i++) {
    if (myNumbers > 0) {
        positiveNumber = myNumbers[i]
    }
}


Аннотации типов для функций:

    - Type Annotation (Аннотации типов) для функций:
Код который мы добавляем для TypeScript, чтобы он понял, аргументы какого типа будет принимать функция
и значение какого типа она будет возвращать

    - Type Inference (Вывод типов) для функций:
TypeScrip пытается сам определить, значение какого типа будет возвращать функця


Аннотации типов для функций:

const add = (a: number, b: number): number => {
    return a + b
}

Выводы типов для функций:
    - TypeScript следит только за типами, за логикой он не следит

- При передачи аргументов нам всегда нужно использовать аннотацию типов. Для аргументов нет вывода типов
- Для возвращаемого значения есть вывод типов, но мы его не будем использовать. У нас есть вывод типа только для возвращаемого значения

Единственная возможность увидеть сообщение об ошибке, это явно указать тип возвращаемого значения
Т.к если тип будет any, или void TypeScript не сможет сообщить нам об ошибке


Void & Never

const logger = (message: string): void => {
    console.log(message)
}

Тип void - означает пустой. Означает что функция не возвращает ничего
Такие функции могут возвращать значение null, также undefined

const throwError = (message: string): never => {
    thow new Error(message)
}

Тип never - означает никогда. Означает что мы никогда не будем достигать конца этой функции
Каждый раз где-то в функции мы будем выбрасывать ошибку. 
Используется только в том случае когда мы полностью уверены, что мы не будем достигать конца функции
И небудем возвращать никакое значение из этой функцции


Деструктуризация 

const todayWeather = {
    date: new Date(),
    weather: 'sunny'
}

const logWeather = (forecast: {data: Date; weather: string}): void => {
    console.log(forecast.date)
    console.log(forecast.weather)
}
logWeather(todayWeather)

Для деструктуризации переменный Date и weather от объекта forecast

const logWeather = ({date, weather}: {data: Date; weather: string}): void => {
    console.log(date)
    console.log(weather)
}
logWeather(todayWeather)

Каждый раз когда мы хотим использовать деструктуризацию мы должны ее заменить на деструктуризационный стейтмент
Мы не используем аанотацию типов вместе с деструктуризацией
Сначало нам нужно сделать деструктуризацию, а затем сделать аннотацию свойств


Аннотации для объектов

const profile = {
    name: 'Jack',
    age: 25,
    coordinates: {
        lat: 1,
        lgn: 20
    },
    setAge(age: number): void {
        this.age = age
    }
}
cosnt { age }: { age: number } = profile

Если мы используем деструктуризацию, ее аннатацию мы должны писать в виде структруры объекта

Получение вложенного объекта:

const { coordinates: { lat, lgn } } : { coordinates: { lat: number; lng: number }} = profile

Свойство coordinates является объектом поэтому внутри мы указываем еще одни фигурные скобки обращаемся к свойствам объекта и указываем аннотации


Массивы в TypeScript 

Typed Array (Типизированные массивы) - массивы в которых каждый элемент - это значение определенного типа

Если мы создаем массив для строк, то массив будет содержать только строки

const colors: string[] = [ 'red', 'green', 'yellow']

Подобная запись с явным приведением типа будет использоваться когда мы инициализируем пустой массив

const dates = [new Date(), new Date()]

cosnt fruitsByColor = [
    ['tomato'],
    ['apple'],
    ['lemon']
]

string [][] - означает двух мерный строковый массив
Это значит что у нас есть массив который содержит массив из строк
В данном примере аннатация типов не нужна, т.к TS поймет тип этого массива

const fruitsByColor: string[][] = [

]

Для чего нужны массивы в TS?

    - TS может сделать вывод типа, когда извлекает значения из массива
    - TS может предотвратить добавление несовместимых типов в массив
    - Мы можем получить помощь использую функции 'map', 'forEach', 'reduce'
    - Гибкость - массивы все же могут содержать значения разных типов  


TS может сделать вывод типа, когда извлекает значения из массива:

const color = colors[0] // тип string
const color = colors.pop()


TS может предотвратить добавление несовместимых типов в массив

colors.push(true) - ошибка!
Мы пытаемся добавить в массив boolean значение в коллекцию в которой только строки


Мы можем получить помощь использую функции 'map', 'forEach', 'reduce'

colors.map((color: string): string => {
    return color.toUpperCase()
})
Используя методы TS будет автоматически выдавать список методов и свойств для переменной 


Массивы со значениями разных типов:

const importantDate: (Date | string)[] = [new Date(), '2022']

В данном случаем автоматически выводит что этот тип массив, и этот массив будет содержать значения типа строка и дата
Если мы при инициализации используем только один тип, но потом хотим использовать два типа, 
тогда мы должны явно показать это TS. Мы должны указать это в аннотации

Когда используются типизированные массивы:
    - каждый раз когда нам нужно представить коллекцию записей в случайном порядке














*/ 

