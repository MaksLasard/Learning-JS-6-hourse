/*
Для того чтобы поставить таймер мы можем использовать setTimeout в рамках этой функции мы можем что-то сделать

Но давайте зададимся вопросом, действительно ли это секунда?
- Для этого нам поможет встроенная глобальная переменная performance
Которая может выдать текущее время относительно запуска performance.now() 

performance.now() - это текущее время  performance.now() - start - текущее время со старта отсчета
start - текущее время для старта

Мы увидим что прошла секунда и 3 миллисекунды 1003
Почему получилось не ровно?
- На самом деле таймер нам не гарантирует что то что у нас запланированно будет выполненно через указанное время
На самом деле оно будет выполнено когда мы дойдем соответсвующей фазы event loop таймеров

Чем больше и нагруженней event loop тем дальше будет отступ от указанного времени

Мы создадим функцию которая будет принимать любой аргумент

Как нам вызвать setTimeout с аргументов
- Первым аргументом идет функция myFunc
- Вторым аргументом время 
И дальше мы можем передавать неограниченное кол-во

Аргумент 'Классный' это аргумент который будет передаваться в функцию как arg

Как нам отменить таймер?
- Мы создаем еще таймер чтобы в нем сделать очистку 
Очистка нашего таймера должна происходить командой clearTimeout()
Куда мы передаем id нашего таймера. setTimeout возвращает этой id. Его нужно записать в переменную

И приложение завершит свою работу

Т.к таймер у нас очищен, у нас нет ничего ожидающего и наше приложение может завершить работу
Потому что callStack пустой висящих таймеров нет

clearTimeout() - хорошо подойдет когда мы хотим дождаться либо сделать таймаут
Например мы хотим сделать запрос к серверу и делаем таймер на 30 секунд
Если сервер не вернул нам ответ за 30 секунд у нас срабатывает таймер в котором мы можем отменить запрос, или пойти в ветку когда нам ничего не вернули
В случае когда у нас ответ вернулся, то мы можем очистить этот таймер. И у нас не будет неправильно ответвления

Обсолютно также работает Interval
- И интервал также возвращает id таймера

Как мы можем что-то запустить после всего, но без всякого отступа по таймауту
setImmediate - это вгновенное выполнение, но после всего
Не требует дополнительных аргументов. Принимает только функцию

Снчала выполниться первый console.log 
Затем зарегистрируется setImmediate который попадет в стек и выполниться когда стек станет пустым
После выполниться второй console.log 

Таймер id мы можем сделать unref() - убирает ссылку
Теперь ничего не выполниться т.к мы убрали ссылку на id таймаута
Не ждет выполнения таймера, выполняет сразу

Чтобы вернуть ссылку нужно испльзовать ref()

Эти методы используются достаточно редко, когда нужно временно выбрасить ссылку, а потом ее вернуть

*/

// const start = performance.now()

// setTimeout(() => {
//     console.log(performance.now() - start)
//     console.log('Прошла секунда!!')
// }, 1000)

// function myFunc(arg) {
//     console.log(`Аргумент => ${arg}`)
// }
// setTimeout(myFunc, 1500, 'Классный')

// const timerId = setTimeout(() => {
//     console.log('BOOOM!!')
// }, 5000)

// setTimeout(() => {
//     clearTimeout(timerId)
//     console.log('Очищено!')
// }, 1000)

// const interval = setInterval(() => {
//     console.log(performance.now())
// },1000)

// setTimeout(() => {
//     clearInterval(interval)
//     console.log('Очищен interval!')
// }, 5000)

// console.log('Перед выполнением!')

// setImmediate(() => {
//     console.log('Выполнилось после всего!!')
// })

// console.log('После выполнения!')

const timerId = setTimeout(() => {
    console.log('BOOOM!!')
}, 5000)

timerId.unref()

setImmediate(() => {
    timerId.ref()
})