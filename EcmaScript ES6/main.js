'use strict'

// function hoisted() {
//     age = 26 // Если мы обращаемся к переменной age еще до того как она была объявлена, но при этом делаем это внутри функции, то такое возможно
// }
// let age
// hoisted()
// console.log(age)

//------Стрелочные функции-----//

const sum = (a, b) => {
    return a + b
}
const sum = a => {
    return a ** 3 // Специальный оператор возведения в степень
}
const sum = a => a ** 3 // Сокращенная запись без return. Лямда функции

// Преимущества стрелочных функций
// Если у нас присутствует всего лишь 1 аргумент, то мы можем убрать () скобки. Если у нас 2 параметра и более убрать скобки мы не можем
// Если наша функция пишется в одну строчку и у нее присутствует один return, то мы можем сократить данный код
// Если нету фигурных скобок, то в таком случае JavaScript считает что полученное значение нужно вернуть

setTimeout(() => {
    console.log('After 1 second') // Можно сократить
}, 1000)

setTimeout(() => console.log('After 1 second'), 1000) // Сокращенная запись, если 1 строчка действия

// Контекст стрелочных функций
function log() {
    console.log(this)
}
const arrawLog = () => console.log(this)

const person = {
    name: 'Elena',
    age: 20,
    log: log,
    arrawLog: arrawLog,
    delayLog: function() {
        const self = this
        window.setTimeout(function () {
            console.log(self.name + '' + self.age)
        }, 500)
    }
}
person.log() // Получаем объект который указывает на сам объект в контексте которого это было вызванно
person.arrawLog() // Получаем пустой объект, который указывает на глобальный объект в node.js который называется global 
// Если запускаешь в браузере будет указывать на объект window

// Когда мы создаем функцию через ключевое слово Function, то данный синтаксис он берет и создает как-бы собственый контекст и у него присутствует ключевое слово this
// Которое указывает на функцию в контексте объекта которого была вызвана

// Когда мы создаем стрелочную функцию, у нее нет собственного контекста, он не создает его. 
// Поэтому внутри стрелочных функций ключевое слово this всегда указывает на контекст который стоит выше

person.delayLog() // Получаем undefined undefined
// Почему мы получаем underfined? Если внимательно посмотрим, то delayLog определена как функция через ключевое слово function
// И поэтому контекст внутри этой функции указывает на объект person, но если мы посмотрим внутри присутствует еще одно слово function
// И получается внутри 2 функции ключевое слово this указывает на объект в контексте которого это было вызвано, а функция setTimeout доступна у объекта global в node.js 
// И у глобального объекта нет таких переменных как name и age

// Решение данной проблемы: 1. Переопределить контекст
// Мы создадим переменную self которая равняется ключевому слову this в функции delayLog, и обращаться не к ключевому слову this , а self.name
/*
const person = {
    name: 'Elena',
    age: 20,
    log: log,
    arrawLog: arrawLog
    delayLog: function() {
        const self = this
        window.setTimeout( () => {
            console.log(this.name + '' + this.age)
        }, 500)
    }
}
*/
// Мы можем записать как стрелочную функцию и обращатся к ключевому слову this
// Данная функция не создает своего контекста поэтому this будет указывать на объект person

//---Параметры по умолчанию--//

function compute(a, b = 20) { // Синтаксис добавления значения по умолчанию
    return a + b
}
console.log(compute()) // Функция ожидает 2 параметра, но мы ничего не передаем и получаем NaN
// Часто бывает что если мы не передаем какой-то аргумент, то было бы не плохо сделать его по умолчанию
// В JS доступен удобный синтаксис: там где мы принимаем параметры написать присвоение по умолчанию
// Мы можем передавать какое-то свое значение и именно оно будет в приоритете

// С дефолтными параметрами очень важен порядок что в любом случае нужны оба параметра либо свои значения, либо по умолчанию

// Так же мы можем задавать дефолтные значения из других переменных 
const defaultB = 30;
const getDefault = c => c * 2 
// function compute1(a, b = defaultB)
function compute1(a, b = getDefault(10)) { // Синтаксис добавления значения по умолчанию из других переменных 
    return a + b // function compute1(a, b = getDefault(a))
}
console.log(compute1())

// Так же в качестве дефолтного значения мы можем вызывать определенные функции

//---Строки---//
// Мы можем писать обратные ковычки `` в которых доступна интерполяция. Можем использовать функции, тернарные операторы 
// Внутри них можно использовать другой тип ковычек 

// Так же в обратных ковычках сохраняются пробелы
const inVisible = () => Math.random() > 0.5
// Функция будет возвращать какое-то случайное число. И будем спрашивать если Math.random() > 0.5, то тогда я получу true
// ${inVisible() ? `<p>Visible</p>` : ''}
// Внутри обратных ковычек можно также пердавать функции
// С помощью тернарного оператора ? если true будем выводить шаблон, если false ,то пустую строку
// Если в переменной inVisible число меньше 0.5 шаблон не будет показываться 

// Методы строк 
const str = 'Hello!'

console.log(str.startsWith('He')); // Проверяет начинается ли строка с тех символом которые мы введем - true
console.log(str.endsWith('He')); // Проверяет заканчивается ли строка на определенные символы
console.log(str.includes('llo')); // Метод который позволяет спросить есть ли такая подстрока в исходной строке 
console.log(str.repeat()); // Метод позволяет продублировать определенное кол-во раз строчку
console.log(str.trim()); // Метод позволяет удалить пробелы слева и справа
console.log(str.trimEnd()); // Удалить пробелы справа
console.log(str.trimStart()); // Удалить пробелы слева
console.log(str.padStart(10, '1234')); // Позволяет задать данной строке минимальное значение длинны, способ наполнения 
// В результате получится 4 пробела, т.к hello длинна всего 5 символов. Если символов не хватает для заполнения пробелов строка идет по новому циклу и добавляет еще 1 '12341Hello'
console.log(str.padEnd(10, '1234')); // Тоже самое только с концп 

// Операторы Rest и Spread
// 2 очень похожих оператора которые отличаются только контекстом их применения 
function average(a, ...args) { // Функция которая будет считать среднее значение 
    return args.reduce((acc, i) => acc += i, 0) / args.length
}
// Будет принимать в себя некоторый массив, далее вы можем посчитать усредненное значение с помощью функции reduce
// Основной концепт, что мы передаем седа функцию callback. Принимаем некоторый acc - акумулятор который будет выполнятся по каждой итерации. И непосредственно сам элемент
// Далее мы просто будем возвращать аккумулятор acc, который будет сложен с элементом i
// Начинать мы будем с 0 значения. И все будем делить на длинну массива
console.log(average(5, 10, 20, 30, 40))
// Если вызвать функцию без квадратных скобок, выдаст ошибку т.к у типа данных нет метода reduce

// Если мы не знаем какое кол-во параметров поступает нам в функцию, то мы можем применить три точки ... и сказать в какую переменную мы хотим все это положить
// При этом мы можем получать некоторые параметры которые нам нужны
// Аргумент а будет принимать в себя 5, а все остальное в массив args

// Оператор Spread
const array = [1, 2, 3, 5, 8, 13] // Получим просто массив
console.log(...array) // Применим оператор Spread
// Получаем те же самые значения ,но без массива 
// Мы можем узначть максимальное значение в массиве 
console.log(Math.max(...array)) // Это не сработает т.к оператор max принимает в себя НЕ МАССИв
// Клонирование массива
// Так же с помощью оператора троеточие может клонировать массив
const fiv = [1, ...array] // Взяли старый массив и развернули все значения в новый массив

// Деструктуризация

// Данный фунционал позволяет нам более быстро получать определенные значения 
const array = [1, 2, 3, 5, 8, 13]
// Например: Мы можем сразу забирать из массива какие-то нужные значения 
const [a, b = 42, ...c] = array 
console.log(a, b, c) // 1 2 [3, 5, 8, 13]
// const a = array[0] - запись идентична первой
// const b = array[1]
// Мы создаем переменные a, b и их оборачиваем в квадратные скобки. И дальше говорю, у какой переменной/массива мы их создаем
// Мы также можем применять оператор spread забрав все остальные значения в переменную c
// Переменная с будет массив состоящая из всех остальных значений которые есть в массиве

// Благодаря данному синтаксису мы также можем задавать значения по умолчанию
// Если вдруг переменная b будет неопределина, тогда мы зададим значение 42
// Если 2 элемент в массиве будет undefined, то переменная будет равна 42

// Мы можем записывать таким образом 
const [a,, c] = array
console.log(a, c)
// Предпололожим что нам нужен не 0 и 1 элемент, а 0 и 2 элемент. И поэтому мы можем написать такой же синтаксис 
// Переменнпя b нам не нужна, мы можем ее просто удалить. И оставить такой синтаксис, что тоже валидно для JS
// Только теперь мы уже не создаем не нужных переменных

// Object - как данный оператор работает с объектами
const adress = {
    country: 'Russia',
    city: 'Moscow',
    street: 'Lenin',
    concat: function() {
        return `${this.country}, ${this.city}, ${this.street}`
    }
}
const {city, country, street, concat: adressConcat} = adress // адрес это объет от которого будут получать ключи через {} скобки
console.log(city) // Такой же синтаксис только мы сразу получаем ключи объекта
// Мы будем создавать отдельные переменные которые ровняются ключам данного объекта
// Так же мы можем получить функцию concat, и функцию мы можем так же забирать. Но с функциями есть определенная особенность

// В данном случае мы сразу получаем нужные ключи, это называется деструктцризация, только внутри объектов
/*
Особенность использования функций 
Если мы вызовем функцию console.log(concat()), то мы получим 3 раза undefined

Т.к в данном случае функция вот так вот забирается 
    function() {
        return `${this.country}, ${this.city}, ${this.street}`
    }
И здесь мы работаем с контекстом this которого впринципе не присутствует у глобального объекта
Мы можем решить данную ситуацию сonsole.log(concat.call(adress)) вызвать метод call и передать нужный нам контекст в данном случае это объект adress

Но при деструктуризации мы можем менять названия переменных:
Мы например говорим что получаем функцию concat(). Но мы хотим не создавать функцию concat(), а хотим занести ее значение в переменную 
Скажем adressConcat - const {city, country, street, concat: adressConcat} = adress

Теперь у нас нет функции concat, а есть функция adressConcat. 
Также мы можем задавать значения по умолчанию const {city, country, street = 'Tverskay', concat: adressConcat} = adress
Используется когда значение ключа undefined

const {city, ...rest} = adress
Получаем отдельную переменную city, а остальные параметры которые у нас есть мы помещаем в объект rest
console.log(city); - результат Moscow
console.log(rest); - результат { country: 'Russian', concat: [Function: concat] }

Объект rest содержит в себе все остальные поля которые присутствуют в объекте adress, за исключением city
Потому что мы вытащили city отдельно

Также мы можем создавать новые объекты. Мы можем взять и создать новый объект
const newAdress = {...adress, street: 'Tverskay'}
console.log()

Внутри данного объета мы можем взять и развернуть другой объект например adress
В данном случае мы получим копию данного объекта
Но что интересно, мы можем менять некоторые поля, и добавлять новые 
*/

/*
Объекты: 
- 
const cityField = 'city'
const job = 'Frontend',
const person = {
    age: 26,
    name: 'Irina',
    job,
    [cityField + Date.now()]: 'Saint-Peterburg',
    'country-live': 'Russia', - можем писать свойства в ковычках
    print:() => 'person', - такие методы не работают с контекстом
    toString() { - такие методы работают с контекстом 
        return Object
            .keys(this) - возвращает массив
            .filter( key => key !== 'toString')
            .map( key => this[key])
            .join(' ')
    }
}
Мы будем брать все ключи объекта и объединять в результирующий массив в одну строчку
Нововедение в JS это функция Object.keys(). Позволяет взять ключи у объекта и пробежаться по ним 
В данном случае мы будем пробегаться по ключевому слову this. Т.к мы используем ключевое слово function

Дальше с помощью оператора .map где мы получаем ключ и будем возвращать значение this
Учитывая то что это массив мы можем вызвать метод .join() и соеденить в единую строчку

Сейчас если мы описываем какую-то функцию внутри объекта то не обязательно писать ключевое слово function мы можем просто его удалить
Теперь внутри объектов мы можем создавать функции(методы), но которые будут являтся стрелочными функциями

Например функция print которая внутри не может работать с контекстом this т.к мы уже разобрали
Но при этом она может делать какие-то базовые вещи например возвращать строку главное без контекста this
Разница только в том что такие методы не работают с контекстом 

Но также мы можем задавать еще и динамические ключи
Сейчас вместо ключа мы можем написать [] квадратные скобки и какое-то значение []: 'Saint-Peterburg',
Внутри [] квадратных скобок мы можем написать какую-то строку которая будет являтся ключом данного объекта
Например мы можем использовать переменную cityField: [cityField]: 'Saint-Peterburg',

Также мы можем делать определенные монипуляции скажем прибовлять значение Date.now()
Идея в том что описывая ключи в квадратных скобках мы можем писать какую-то динамику которая в итоге станет ключом данного объекта [cityField + Date.now()]: 'Saint-Peterburg',

Мы создадим переменную job = Frontend. Чтобы использовать ключ job: job, который принимает переменную job

Когда ключ и значение совпадают, то мы можем избавиться от ключа написав просто переменную job,

Новые методы ES6+ для работы с объектами:

const first = {a: 1}
const second = {b: 2}

- Метод у глобального объекта Object который называется is(). Проверяет на эквивалентность разные значения 
console.log(Object.is())

- Метод console.log(Object.assign({}, first, { - {a: 1, d: 3, c: 4}.
    d: 3,
    c: 4
})) - позволяет объединять определенные объекты
Мы возьмем объект first и скажем что нам его нужно модифицировать с объектом second
На выходе мы получаем объединеный объект {a: 1, b: 2}. Теперь объект first изменился 
Если мы хотим создать новый объет, то добавляем первым аргументом пустой объект

const obj = Object.assign({}, first, { - {a: 1, d: 3, c: 4}.
    d: 3,
    c: 4
}) 

3 Метода которые позволяют по разному работать с объектами:
console.log(Object.entries(obj))
- Мы получим дву мерный массив состоящий из массивов [ ['a', 1] , ['b', 2] , ['c', 3] ]
- Один из способов представления объекта 

console.log(Object.keys(obj)) - возвращает массив ключей 
console.log(Object.values(obj)) - возвращает массив значений объекта


import и export:
Вся идея заключается в том что присутствует очень удобный синтаксис для соединения и взаимодействия различныъ файлов 

export const COLOR = '#bababa'

export function (a, b) {
    return a + b
}

Все файлы в JavaScript являются модулями 
Чтобы другие модули смогли увидеть созданную нами константу нужно ее экспортировать 

Чтобы экспортированные модули можно было получить в других файлах (модуля/компонентах) нужно:

import Logger, {COLOR, compute} from './module'

То мы получаем объект итоге от модуля где происходил экспорт
У которого мы сразу же можем с помощью деструктуризации получить определенные поля
После слова from мы указываем путь до модуля откуда происходил export

В фигурных скобках мы получаем объект. Мы знаем что у этого объекта есть переменная COLOR и функция compute
И мы можем смело ими пользоваться в другом модуле

compute(1, 2)
console.log(COLOR)

При этом присутсвует еще и другой синтаксис
- Например мы можем экспортировать что-то по дефолту

cosnt privateVariable = 42

export default {
    log() {
        console.log(privateVariable)
    }
}

Если объявленная переменная никуда не экспортируется она считается приватной 
В данном случае импорт будет выглядеть немного иначе

Чтобы нам получить дефолтный экспорт нам нужно описать какой-то объект уже без фигурных скобок Logger
Учитываем что у нас был export default можем записать любое название. Т.е мы не привязанные к определенному имени

Зачастую лучше использовать именнованыее экспорты и импорты
Также мы можем импортировать все, но дальше мы обязаны сказать в какую переменную мы хотим положить Module 
from - откуда. Из файла module

import * as Module from './module'

Теперь у нас будет доступ к все экспортам в './module'
Чтобы получить метод log() мы обращаемся к полю default и у него присутствует метод log()

Module.default.log()

Классы:
- Теперь для работы с классами присутствует более удобный синтаксис 

class Person {
    type = 'human'

    constructor(name) {
        this.name = name
    }
    greet() {
        console.log(this.name)
    }
}
const max = new Person('Max')
console.log(max.type)

С помощью ключевого слова class. И далее в фигурных скобках мы можем описывать тело этого класса
Если мы хотим определить конструктор, то пишем функцию constructor()
И в нее мы получаем определенный набор параметров допустим параметр name
С этим параметром мы можем делать что угодно в том числе занести его в ключевое слово this
Теперь у инстенса класса Person будет присутствовать поле name

Если мы захотим этим воспользоваться мы создаем переменную max которая будет являться новым персонажем 

const max = new Person('Max')

Если мы хотим задавать какие-то методы внутри класса, то мы можем их создавать
Мы можем обращатся к инстансу класса и вызывать нужный метод 
Также по анологии мы можем создавать переменные внутри класса например тип персонажа

Внутри классы устроенны на прототипах 
Тепрь мы можем более удобно устраивать наследования внутри этих классов 
У насс уже есть класс Person и предположим что мы хотим сделать какой-то более частный клас например: Programmer
Который будет основываться на классе Person
extends - ключевое слово для наследования классов. А далее указать, от какого класса мы хотим наследоваться 

class Programmer extends Person {
    constructor(name) {
        super(name)

        this._job = job
    }

    get job() {
    return this._job.toUpperCase()
    }

    set job(job) {
        if (job.length < 2 ) {
            throw new Error('')
        } else {
          this._job = job 
    }

    }

    greet() {
        super.greet()
        console.log(Rewritten) - переписанный метод
    }
}



Далее например мы хотим реализовть метод constructor. Мы можем это сделать, но он будет подсвечиваться красным
Учитывая что мы наследуемся от какого-то класса, ошибка нам говорит что мы не вызваем данный конструктор Person
Чтобы нам этого избежать мы можем обратится к методу который называется super()

С этим ключевым словом есть одна особенность 
В конструктор мы будем принимать поле name, и это имя мы будем передавать в супер класс, и также будет принимать какую-то профессию
После того как будет вызван конструктор родителя мы уже можем делать какую-то свою логику
Мы занесем все это в переменную _job

Далее мы создадим инстанс уже от класса Programmer

const frontend = new Programmer(Max, Frontend)
console.log(frontend)

Если мы посмотрим в консоль, то получим обычный объект. Но теперь у него есть 
Programmer { type: 'human', name: 'Max', _job: 'Frontend' }

Что интересно мы также можем допустим у данного объекта вызывать метод greet()
frontend.greet() - потому что он доступен у нас в родительском классе. Но при этом мы можем его переписывать

Если мы хотим при вызове методы greet также вызывать родительский метод, то мы можем это сделать с помощью ключевого слова супер
Только теперь мы уже его не вызываем, а обращаеся к нему как к объекту и вызываем родительский нужный метод

При этом в классах нам также доступен функционал геттеров и сеттеров

Вместо того чтобы просто обращаться к this._job = job мы просто сделаем для него геттер

get job() {
    return this._job.toUpperCase()
}

геттер который будет возвращать (ключевое слово this) дальше поле _job и например мы можем его трасформировать 
Теперь если мы будем обращатся к console.log(frontend.job) причем мы обращаемся без круглых скобок
Т.е это не функция, а обычный объект 

По анологии мы можем задавать сеттеры 
Соответсвенно когда мы будем говорить frontend.job = '1' и снова бедем получать значение от геттер, то получаем 1

Зачем нам нужны get и set
- Например мы можем писать различные валидации

if (job.length < 2 ) {
    throw new Error('')
} else {
   this._job = job 
}

Статические методы в классах:

class Util {
    static average(...args) { - считает среднее значение элементов (переданных)
        return args.reduce((acc, i) => acc += i, 0) / args.length
    }
}
Мы не можем через точечную запись обратится к average Util.average - т.к у нас нет доступа
Но мы можем создать переменную через которую можно будет обратится 

const util = new Util()
console.log(util.average(1, 1, 2, 3, 5, 8, 13))

Но если мы сделаем этот метод статическим, то в таком случае нам не нужно будет делать инстанс класса util
Мы мжем сразу обратится Util.average(1, 1, 2, 3, 5, 8, 13) и передать необходимые числа

const res = Util.average(1, 1, 2, 3, 5, 8, 13)
console.log(res)

За счет того что метод или поля является статическим, то соответственно мы можем на прямую обращаться к классу и вызывать у него нужный метод

Symbol(Символы)
- Это седьмой тип данных в JavaScript который появлися с EcmaScript 6
- И он нужен чтобы задавать какие нибудь уникальные ключи. Символ по сути и это уникальное значение 

У нас есть глобальный класс Symbol и с помощью него мы можем создавать какие-то другие символы

const sybol = Symbol('demo')
const other = Symbol('demo') - мы создали символ с точно таким же описанием 

console.log(symbol)
console.log(other)

console.log(symbol === other) // false

Несмотря на то что мы создавали символы как бы одинаково они все равно у нас разные 
В этом и заключает основная особенность символов, что они обсолютно уникальны 

const obj = {
    name: 'Elena',
    [symbol]: 'meta'
}
Мы можем задать динамический ключ который будет являтся символом, это их премое предназначение
console.log(obj[symbol]) // demo
console.log(obj[other]) // undefined

[symbol]: - данные поля они как бы сокрыты 
Цикл for in бежит не только по полям объекта, но еще и по протатипу. Символов данный цикл не видит 

Symbol - нужны для задания определенных мето данных для каких-то объектов, функций или классов и для того чтобы их использовать


Генераторы и итераторы:

const array = [10, 20, 30, 40]
const str = 'Hello'

console.log(array.[Symbol.iterator])
console.log(str.[Symbol.iterator])

Означает что для массвов и для строк по умолчанию определен Symbol.iterator

Использование 

const iter = array[Symbol.iterator]()
const iter = str[Symbol.iterator]()

console.log(iter.next()) // { value: 10, done: false }
console.log(iter.next()) // { value: 20, done: false }
console.log(iter.next()) // { value: 30, done: false }
console.log(iter.next()) // { value: 40, done: false }
console.log(iter.next()) // { value: undefined, done: true } - итератор закончился 

Идя в том что можем итеративно получать определенные элементы у тех оюъектов у которых определен Symbol iterator
С строкой тоже самое. На каждой итерации мы получаем символ строки

console.log(iter.next()) // { value: 'H', done: false }
console.log(iter.next()) // { value: 'e', done: false }
console.log(iter.next()) // { value: 'l', done: false }
console.log(iter.next()) // { value: 'l', done: false }
console.log(iter.next()) // { value: 'o', done: false }
console.log(iter.next()) // { value: undefined, done: true }

for (let item of array) {
    console.log(item)
}

Мы можем этим воспользоваться и создавть свои собственные итераторы

cosnt country = {
    values: ['ru', 'kz', 'ua', 'by']
    [Symbol.iterator]() {
        let i = 0
        return {
            next: () => {
                const value = this.value[i]
                i++
                return {
                    done: i > this.values.length
                }
            }
        }
    }
}

for (let item of country) {
    console.log(item)
}

Тепрь мы можем определить этого объекта уникальный символ итератора который как раз работает с циклом for of
Тепрь мы можем применить цикл for of для нашего кастомного объекта country

Применяя [Symbol.iterator] мы можем описывать свою какую нибудь кастомную логику

Генератор:


















*/