/*

Раньше в React использовались классовые компоненты

Оснавная ключевыя идия реакт компонентов
- Есть определенный стейт. Т.е есть объект описывающий состояние компонента и если он меняется, то реакт перерисовыет непосредственно ту область где этот стейт выводится

Если мы использовали классовые компоненты, то мы там использовали метод this.setState({a: 1}) -> this.render()
Туда мы добавляли какое-то новое значение, и после этого вызывался метод this.render()
Который брал и перерисовывал нам компонент

Все эти методы они наследовались от базового класса от которого мы наследовались в реакте
Но позже реакт решил перейти полностью к функциональным компонентам, чтобы все наши компоненты были не классами, а функциями

Почему? 
Как минимум потому что с этим проше взаимодействовать чем с классами
Плюс меньше кушает ресурсов, потому что мы не наследуемся от других сущностей
У нас всего лишь есть функция и всё

Соответственно чтобы полностью мигрировать на функциональные компоненты нужно было как-то соблюсти динамику 
Как минимум как-то взаимодействовать с стейтом. Как раз для этого появились Хуки

Хуки - это просто абсолютно изолированные функции которые предостовляет Реакт, но которые позволяют посути полностью имплементировать 
Весь функционал Реакта в базовых компонентах функциональных 

Вся эта идея взята из функционального программирования и у нее также есть еще плюсы
- В том что код который мы пишем становится более гибким и более масштабируемым

// useState
- Предназначен для того чтобы взаимодействовать с стейтом (состоянием)

import React, {useState} from 'react'


function App() {
    const counterState = useState(0)

    retrun (
        <div>
            <h1>Счетчик</h1>
            <button>Добавить</button>
            <button>Убрать</button>
        </div>
    )
}

export default App

Чтобы нам поработать с счетчиком нам нужно для начала ввести некоторое состояние
Мы сразу будем вводить это состояние через новый хук useState

Он используется следующим образом:
- Мы можем его получить из самого Реакта (Объекта реакт). У него есть метод useState

Но обычно вы можете заметить его использование немного иным способом, когда мы отдельно достаем этот Хук с помощью ES6 синтаксиса
И используем как обычную функию

С помощью Хука useState мы начинаем взаимодействовать с стейтом 
- Как параметр в данную функцию мы передаем начальное состояние - этого состояния
В нашем случае это будет 0, мы хотим чтобы наш счетчик начинался с нуля

Теперь важно то, что возвращает нам Хук useState
Если мы посмотрим в косоль что такое counterState
То сдесь мы увидим возможно неожиданный результат, мы получаем здесь массив 

Где первый элемент данного массива это непосредственно само состояние
А второй элемент массива это фукния. Функия которая позволяет изменять данное состояние 

Array(2) 
    0: 0, 
    1: f()

И вот в чем заключается идея:
- Функция Хук useState нам возвращает кортеж
Кортеж это массив с заранее определенными элементами которые в нем находятся 
Где первый элемент [0] по индексу ноль. Это непосредственно тот стейт который мы должны определять в сам шаблон
А второй элемент это функция позволяющая изменять этот стейт для того чтобы реакт смог отследить что:
- Стейт изменился и перерисовать шаблон для того чтобы мы напрямую не меняли данное состояние 
















*/