/*
SOLID. Принципы ООП
    - получил широкое распространение в ООП подходе к разработке

Общая идея - что использование сразу несколькиз принципов как единого целого намного лучше чем
использование принципов по отдельности

Рекомендации по правильной организации аргитектуры кода

Плюсы:
    - инкапсуляция отдельных сущностей
    - прозрачная организация архитектуры

SOLID - это 5 разных принципов
    - Single Responsybility (Принцип единой ответсвенности)
    - Open-Closed (Открытости и закрытости)
    - Liskow Substitution (Принцип подстановки Барбары Лисков)
    - Interface Segregation (Принцип разделения интерфейсов)
    - Dependensy Inversion (Инверсия зависимостей)

Каждый из перечисленных принципов это просто рекомендация, совет или лучшие практики по организации архитектуры проекта
У каждого есть своя область и граница применения


Single Responsybility (Принцип единой ответсвенности):
    - У модуля должна быть только одна причина для изменения. Или класс должен отвечать только за что-то одно

Основная идея это организовать код таким образом, чтобы в случае возникновения изменения задействовать
наименьшее количество модулей. В идеале при возникновении действия должен затрагиваться только один класс

Пример:

class Auto {
    constructor(model: string) {}
    getCarModel() {}
    setCarModel() {}
}
class CustomerAuto {
    saveCustomerOrder(o: Auto) {}
    getCustomerOrder(id: string) {}
    removeCustomerOrder(id: string) {}
}
class AutoDB {
    updateCarSet(set: object) {}
}

Данный принцип помогает декомпозировать или разбивать общие конструкции на независимые модули
Уменьшать межмодульную связь и помогает изменять меньшее количество при внесении изменения
А также ограничивать некотролируемое влияние этих изменений на несвязанные сущности


Open-Closed (Открытости и закрытости)
    - модуль должен быть открыт для раширения, но закрыт для изменения

Основная идея этого принципа - это разработка устойчиваго к изменениям приложения
И закладывание такой архитектуры чтобы небольшое изменение класса не затрагивало кучу связанных с ним модулей

Пример:

abstract class Auto {
    abstract getPrice(): string
}
class Tesla extends CarPrice {
    getPrice() {
        return '80 000$'
    }
}
class Audi extends CarPrice {
    getPrice() {
        return '50 000$'
    }
}
class Bmw extends CarPrice {
    getPrice() {
        return '70 000$'
    }
}


Liskow Substitution (Принцип подстановки Барбары Лисков)
    - Необходимо, чтобы подклассы могли служить заменой для своих супер классов

Функции использующие базовый тип должны иметь возвожность использовать его подтипы
Основная цель это проектировать логику таким образом чтобы класса наследники могли спокойно использоваться вместо родителей
Но в большинстве случаем из за дополнительных проверок логики, лучше всего для общих классов использовать общий интерфейс,
а не наследовать один класс от другого


Interface Segregation (Принцип разделения интерфейсов)
    - Сущности не должны зависеть от интерфейсов которые не используют 

Одна из проблем ООП это при наследовании класс потомок может получить кучу ненужной функциональности которая в нем не используется
Чтобы не сталкиваться с данной проблемой интерфейсы принято декомпозировать

Пример:

inteface TeslaSet {
    getTeslaSet(): any
}

inteface AudiSet {
    getTeslaSet(): any
}

inteface BmwSet {
    getTeslaSet(): any
}

class Tesla implement TeslaSet {
    getTeslaSet(): any { }
}

class Audi implement AudiSet {
    getTeslaSet(): any { }
}

class Bmw implement BmwSet {
    getTeslaSet(): any { }
}

Плюсы данного подхода:
    - снижение зависимостей между модулями 
    - при наследовании нет не нужной функциональности которую требуется реализовывать
    - при внесении изменений затрагиваются только нужные части, а не все зависящие модули
    - декомпозиция, т.е разделение сущностей


Dependensy Inversion (Инверсия зависимостей)
    - содержит 2 основных утрверждения
        - модули высших уровней не должны зависеть от модулей низких уровней оба должны зависить от абстракций
        - абстракции не должны зависеть от деталей, детали должны зависеть от абстракций

Верхнеуровневые сущности не должны зависеть от нижнеуровневых реализаций
Любый зависимости лучше выносить в абстракции т.е инкапсулировать в отдельных сущностях

Основной задачей является уменьшение межмодульных зависимостей, а следовательно повышение простоты чтения, понимания, тестирования
















*/